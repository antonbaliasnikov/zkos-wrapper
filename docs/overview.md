# ZKOS Wrapper - Overview

## Why do we need this wrapper?

In airbender we can proof an arbitrary number of RiscV cycles with multiple proofs and compress them into a single proof with recursion. But when it come to L1 verification it could be expensive. So our purpose is to wrap the last airbender proof into Snark.
We already use [Snark wrapper](https://github.com/matter-labs/zksync-crypto/tree/main/crates/snark-wrapper) to wrap boojum Stark proofs into Snark. So we only need to implement airbender -> boojum wrapper. So in the end our full wrapping pipeline will look like this:
![diagram](../diagram.svg)

**Note:** we also use `Compression` step, which is just boojum -> boojum wrapper, to make proof smaller to fit it into `SnarkWrapper`.

## ZKOS Wrapper parts

This repository contains the following main components:
- [wrapper](../wrapper/) - the main part with wrapper itself
    - [wrapper-inner-verifier](../wrapper/src/wrapper_inner_verifier/) contains the inner `verify` function used for verification last airbender proof
    - [wrapper-utils](../wrapper/src/wrapper_utils/) contains circuit representation of airbender structs and traits used for verification
    - [transcript](../wrapper/src/transcript/) contains blake hash (for merkle trees and transcript) and transcript (for random challenges)
    - [circuits](../wrapper/src/circuits/) contains defined circuits for all three parts of the pipeline: `risc_wrapper`, `compression` and `snark_wrapper`
- [wrapper-generator](../wrapper_generator/) - generates code used in the inner `verify` function
- [circuit-mersenne-field](../circuit-mersenne-field/) - circuit representation of Mersenne field used in the wrapper

## Why do we need `wrapper-generator`?

Usually, verification function takes VK (verification key) as an argument to specify what exact circuit we want to verify. However, in our case we are going to hardcode all the inner airbender circuit parameters into the wrapper itself. This is done for optimization purposes. So we use `wrapper-generator` to generate two files located in [wrapper-inner-verifier/imports/](../wrapper/src/wrapper_inner_verifier/imports/) folder:
- `circuit_layout.rs` - contains the constants specifying geometry of airbender circuit
- `circuit_quotient.rs` - contains the quotient part of verification

These two files completely define the machine of the last airbender circuit. But we also need to verify that the correct code was run during the execution. For this purpose we have `final_state_constants.rs` file that contains two constants:
- `FINAL_RISC_CIRCUIT_END_PARAMS` - the expected commitment of the program run on the last airbender circuit
- `FINAL_RISC_CIRCUIT_AUX_REGISTERS_VALUES` - the expected commitment of all programs run on the previous layers (base program + recursion programs)

**Note:** While `circuit_layout.rs` and `circuit_quotient.rs` are always generated by `wrapper_generator` and used during wrapping, `final_state_constants.rs` are not as necessary to update, as inner constants could be generated during proving/creating vk process.

## Crs
Crs (common reference string) is a trusted setup required for the final Snark (in the inner KZG commitment). You can download it with this command:
```
curl https://storage.googleapis.com/matterlabs-setup-keys-us/setup-keys/setup_2\^24.key --output setup.key
```
The tool also offers to use the 'fake' file - that works for local testing, but must NEVER be used for production cases.

## Testing

You can find the main tests for running all the pipeline in the [wrapper/tests/mod.rs](../wrapper/src/tests/mod.rs). These tests will use fibonachi as a base program and take the last airbender circuit proof as an input. In the end you will get all the intermediate proofs up to the final snark proof.

## Running the wrapper
You can find instructions for running the full pipeline here: [Running end to end](./end_to_end.md).

### Happy wrapping :]
